% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hcr.R
\name{mcdahcr}
\alias{mcdahcr}
\title{mcdahcr conducts the MCDA and returns the TAC multiplier and details}
\usage{
mcdahcr(indat, hsargs, glb, projyear = NULL, outhcr = outhcr, iter = iter)
}
\arguments{
\item{indat}{a list of the array of cpue across all years that forms the
basis of the assessment, the yearnames for the extent of years making up
the cpue data, the aspirational catches from the previous year (that
will be multiplied to give the coming year's aspirational catches), and
a NULL fis and NaS value}

\item{hsargs}{the arguments used within the Harvest strategy's HCR. See the
description for details. if metRover = 0 then no meta rules are
applied}

\item{glb}{the globals object}

\item{projyear}{an index of the year for which the acatch are being estimated
thus, if one has 29 years of data hen projyear would be 30.}

\item{outhcr}{a list of arrays generated by makehcrout within the HS package.
It becomes the repository of all the HS scores and other outputs.}

\item{iter}{which iteration within reps is being run? Needed to output the
scores to outhcr}
}
\value{
a list of the acatch, TAC, TAC multiplier, the score, all the
details and a matrix of the reference points
}
\description{
mcdahcr conducts the MCDA on the basis of a vector of cpue and
other details prescribed in the function's arguments. It returns the
TAC multiplier, the combined score, and all the details of the
calculation. The hcr is a vector of 1:10 values where the cell index
is used to allocate each combined score to a multiplier. The score is
rounded up to the nearest integer and that is the index within hcr.
Thus a score of <=1 points to the first cell, >1 and <=2 points to the
second cell, and so on, up to a score between >9 and <=10 which points
to the last cell. All the arguments used within the mcda are brought in,
and hence are flexible, inside a list named hcrargs. This list includes
the 'wid', the number of years to use in grad4, default=4; the
'targqnt', the quantile for the cpue target level, default=0.55, the
'pmwts', performance measure weights, default = 0.65, 0.25, 0.1 for the
target, grad4, and grad1 PMs respectively, so the order matters; the
'hcr', the harvest control rule scales that transform the combined score
into a TAC multiplier. A vector of 1 - 10 where each cell index
represents the upper limit of the the combined score. Now contains the
metarules that affect the outcome. The final acatch values are
round(acatch,0) so as to be whole numbers and using 'round' leads to the
least error relative to the total of the real numbers. 'floor' and
'ceiling' give biased low and biased high TAC values. Used directly by
aMSE.
}
\examples{
  data(hcrdata)
  iter <- 1
  hsargs <- list(mult=0.1,wid = 4,targqnt = 0.55,
            maxtarg = c(150,150,150,150,150,150,150,150),
            pmwts = c(0.65,0.25,0.1),
            hcr = c(0.25,0.75,0.8,0.85,0.9,1,1.05,1.1,1.15,1.2),
            hcrm3 = c(0.25,0.75,0.8,0.85,0.9,1,1.1,1.15,1.2,1.25),
            startCE = 1992,endCE = 2020,metRunder = 2,metRover = 2,
            decrement=1, pmwtSwitch = 4,stablewts = c(0.4, 0.5, 0.1),
            hcrname="mcdahcr")
    glb <- list(saunames=c("sau6","sau7","sau8","sau9","sau10","sau11",
                           "sau12","sau13"),yrnames=hcrdata$yearnames,
                hyrs=29,pyrs=1,reps=1,hyrnames=1992:2020,pyrnames=2021)
  outhcr <- makeouthcr(glb,hsargs)          
  hcrout <- mcdahcr(hcrdata,hsargs=hsargs,glb,projyear=(nrow(hcrdata$arrce)+1),
                    outhcr,iter)
  str(hcrout)
}
\seealso{
{
\link{getgrad1}, \link{getgrad4}, \link{getscore},
\link{targscore}, \link{getlmcoef}
}
}
