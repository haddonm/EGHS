
#' @title mcdahcr conducts the MCDA and returns the TAC multiplier and details
#'
#' @description mcdahcr conducts the MCDA on the basis of a vector of cpue and
#'      other details prescribed in the function's arguments. It returns the
#'      TAC multiplier, the combined score, and all the details of the
#'      calculation. The hcr is a vector of 1:10 values where the cell index
#'      is used to allocate each combined score to a multiplier. The score is
#'      rounded up to the nearest integer and that is the index within hcr.
#'      Thus a score of <=1 points to the first cell, >1 and <=2 points to the
#'      second cell, and so on, up to a score between >9 and <=10 which points
#'      to the last cell. All the arguments used within the mcda are brought in,
#'      and hence are flexible, inside a list named hcrargs. This list includes
#'      the 'wid', the number of years to use in grad4, default=4; the
#'      'targqnt', the quantile for the cpue target level, default=0.55, the
#'      'pmwts', performance measure weights, default = 0.65, 0.25, 0.1 for the
#'      target, grad4, and grad1 PMs respectively, so the order matters; the
#'      'hcr', the harvest control rule scales that transform the combined score
#'      into a TAC multiplier. A vector of 1 - 10 where each cell index
#'      represents the upper limit of the the combined score. Now contains the 
#'      metarules that affect the outcome. The final acatch values are 
#'      round(acatch,0) so as to be whole numbers and using 'round' leads to the 
#'      least error relative to the total of the real numbers. 'floor' and
#'      'ceiling' give biased low and biased high TAC values. Used directly by 
#'      aMSE.
#'
#' @param indat a list of the array of cpue across all years that forms the
#'     basis of the assessment, the yearnames for the extent of years making up
#'     the cpue data, the aspirational catches from the previous year (that
#'     will be multiplied to give the coming year's aspirational catches), and
#'     a NULL fis and NaS value
#' @param hsargs the arguments used within the Harvest strategy's HCR. See the
#'     description for details. if metRover = 0 then no meta rules are 
#'     applied
#' @param glb the globals object
#' @param projyear an index of the year for which the acatch are being estimated
#'     thus, if one has 29 years of data hen projyear would be 30.
#' @param outhcr a list of arrays generated by makehcrout within the HS package.
#'     It becomes the repository of all the HS scores and other outputs.
#' @param iter which iteration within reps is being run? Needed to output the
#'     scores to outhcr
#'     
#' @seealso {
#'     \link{getgrad1}, \link{getgrad4}, \link{getscore},
#'     \link{targscore}, \link{getlmcoef}
#' }     
#'
#' @return a list of the acatch, TAC, TAC multiplier, the score, all the
#'     details and a matrix of the reference points
#' @export
#'
#' @examples
#'   data(hcrdata)
#'   iter <- 1
#'   hsargs <- list(mult=0.1,wid = 4,targqnt = 0.55,
#'             maxtarg = c(150,150,150,150,150,150,150,150),
#'             pmwts = c(0.65,0.25,0.1),
#'             hcr = c(0.25,0.75,0.8,0.85,0.9,1,1.05,1.1,1.15,1.2),
#'             hcrm3 = c(0.25,0.75,0.8,0.85,0.9,1,1.1,1.15,1.2,1.25),
#'             startCE = 1992,endCE = 2020,metRunder = 2,metRover = 2,
#'             decrement=1, pmwtSwitch = 4,stablewts = c(0.4, 0.5, 0.1),
#'             hcrname="mcdahcr")
#'     glb <- list(saunames=c("sau6","sau7","sau8","sau9","sau10","sau11",
#'                            "sau12","sau13"),yrnames=hcrdata$yearnames,
#'                 hyrs=29,pyrs=1,reps=1,hyrnames=1992:2020,pyrnames=2021)
#'   outhcr <- makeouthcr(glb,hsargs)          
#'   hcrout <- mcdahcr(hcrdata,hsargs=hsargs,glb,projyear=(nrow(hcrdata$arrce)+1),
#'                     outhcr,iter)
#'   str(hcrout)
mcdahcr <- function(indat,hsargs,glb,projyear=NULL,outhcr=outhcr,iter=iter) { 
  # indat=hcrdata;hsargs=hsargs;saunames=paste0("sau",6:13);glb=glb;projyear=30;
  # outhcr=outhcr;iter=1
  saunames <- glb$saunames
  arrce <- as.matrix(indat$arrce)
  nsau <- ncol(arrce)
  yrce <- nrow(arrce)
  pmwts <- hsargs$pmwts
  stablewts <- hsargs$stablewts
  pmwtSwitch <- hsargs$pmwtSwitch
  metRunder <- hsargs$metRunder
  metRover <- hsargs$metRover
  yearnames <- indat$yearnames
  acatches <- indat$acatches
  # define storage matrices
  grad1val <- matrix(0,nrow=yrce,ncol=nsau,dimnames=list(yearnames,saunames))
  grad4val <- targval <- score1 <- score4 <- scoret <- scoretot <- grad1val
  multTAC <- indexI <- grad1val
  refpts <- matrix(0,nrow=nsau,ncol=4,
                   dimnames=list(saunames,c("low","trp","high","realtrp")))
  flagmeta <- matrix(0,nrow=yrce,ncol=nsau,dimnames=list(yearnames,saunames))  
  for (sau in 1:nsau) {  #  sau=25
    pickce <- which(!is.na(arrce[,sau])) 
    ## CM: need to capture the NA years here (or elsewhere) if we want to use
    ## TasHS package for stock assessment
    tmp <- getgrad1(arrce[pickce,sau])                     # grad1
    nec <- length(tmp)
    if (nec < yrce) tmp <- c(rep(NA,(yrce-nec)),tmp)
    grad1val[,sau] <- tmp
    score1[,sau] <- getscore(grad1val[,sau],mult=hsargs$mult)
    tmp2 <- getgrad4(arrce[pickce,sau],wid=hsargs$wid)      # grad4
    nec2 <- length(tmp2)
    if (nec2 < yrce) tmp2 <- c(rep(NA,(yrce-nec2)),tmp2) # allow for 6 and 13
    grad4val[,sau] <- tmp2
    score4[,sau] <- getscore(grad4val[,sau],mult=hsargs$mult)
    # Now estimate target from adaptable period
    tmp3 <- targscore(arrce[pickce,sau],qnt=hsargs$targqnt,mult=hsargs$mult,
                      maxtarg=hsargs$maxtarg[sau]) #targ
    nec3 <- length(pickce)
    scrs <- tmp3$scores
    if (nec3 < yrce) scrs <-  c(rep(NA,(yrce-nec3)),scrs)
    scoret[,sau] <- scrs
    targval[pickce,sau] <- arrce[pickce,sau] # CM mod
    scoretot[, sau] <- pmwts[1] * scoret[, sau] + pmwts[2] * score4[, sau] +
      pmwts[3] * score1[, sau]
    mr3fire <- FALSE  # SHOULD BE CAPTURED IN FLAGMETTA ?
    ## Meta Rules section--------------------    
    if (pmwtSwitch > 0) { # meta rule 3 - part 1  pmwt---------
      # Metarule to switch weights & update scoretot
      if (all(tail(arrce[pickce, sau], pmwtSwitch) > refpts[sau, 2])) {
        tmpmr3 <- diff(arrce[, sau])
        if (all(tail(tmpmr3, pmwtSwitch) > 0)) {
          mr3fire <- TRUE
          scoretot[, sau] <- stablewts[1] * scoret[, sau] + 
            stablewts[2] * score4[, sau] + stablewts[3] * score1[, sau]
          flagmeta[yrce,sau] <- 3.0
        }
      } 
    } # meta rule 3 part 1 finished----------------------
    pickI <- floor(scoretot[,sau]) + 1 # add one to get correct hcr[index]
    pickI[pickI < 1] <- 1
    pickI[pickI > 10] <- 10
    if (pmwtSwitch > 0) {   # meta rule 3 - part 2  hcr shift CM: add------
      multTAC[, sau] <- hsargs$hcrm3[pickI] 
    } else {
      multTAC[, sau] <- hsargs$hcr[pickI] 
    } # meta rule 3 part 2 hcr finished------------
    refpts[sau,] <- tmp3$rp # the only reference point is the target cpue
    # Meta Rules1  STARTS  overs------------------
    if ((metRover > 0) & (!mr3fire)) {
      if (all(tail(arrce[, sau], metRover) > refpts[sau, 2])) { # CPUE above Target for 2 years
        tmp5 <- diff(arrce[, sau])
        if (all(tail(tmp5, metRover) > 0)) {  # got to be increasing for >= 2 yrs
          multTAC[yrce, sau] <- hsargs$hcr[pickI[yrce]] # already in place
        } else {
          multTAC[yrce, sau] <- 1 # if above but not increasing assign 1 to multTAC for no change
          flagmeta[yrce,sau] <- 1.0
        }
      }
    }  # end of meta rule 1---------------------
    if (metRunder > 0) {  # MetaRule2 starts  under ----------------------------
      if (all(tail(arrce[, sau], metRunder) < refpts[sau, 2])) {
        # CPUE below Target for 2 years
        tmp6 <- diff(arrce[, sau])
        if (all(tail(tmp6, metRunder) >= 0))  {
          multTAC[yrce, sau] <-  1 # if below and increasing 2 years assign 1 to multTAC for no change
          flagmeta[yrce,sau] <- 2.0
        } else {
          multTAC[yrce, sau] <- hsargs$hcr[pickI[yrce]] # already in place
        }
      }
    } # end meta rule 2-----------
    indexI[,sau] <- pickI
  } # end of sau loop
  startyr <- glb$hyrs + 1
  inyr <- projyear - startyr + 1
  outhcr$g1s[inyr,,iter] <- score1[yrce,]
  outhcr$g4s[inyr,,iter] <- score4[yrce,]
  outhcr$targsc[inyr,,iter] <- scoret[yrce,]
  outhcr$finalsc[inyr,,iter] <- scoretot[yrce,]
  outhcr$index[inyr,,iter] <- indexI[yrce,]
  outhcr$catchmult[inyr,,iter] <- multTAC[yrce,]
  outhcr$metaflag[inyr,,iter] <- flagmeta[yrce,]
  outhcr$cetarg[inyr,,iter] <- refpts[,"trp"]
  acatch <- acatches * multTAC[yrce,] # to give whole numbers (mod by CM to 1)
  TAC <- sum(acatch,na.rm=TRUE)
  details <- list(grad4=grad4val,grad1=grad1val,targval=targval)
  out <- list(acatch=acatch,TAC=TAC,outhcr=outhcr,details=details,refpts=refpts)
  return(out)
} # end of mcdahcr